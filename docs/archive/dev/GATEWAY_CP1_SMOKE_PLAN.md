# Gateway CP1-Smoke Plan & Gap Analysis

**Date**: 2025-01-27  
**Status**: üìã Planning  
**Vector**: Gateway CP1-smoke / contract-smoke with Router  
**Endpoint**: `POST /api/v1/routes/decide`  
**Version**: 1.0

## Executive Summary

This document outlines the plan for Gateway CP1-smoke verification, focusing on the minimal but strict scenario that guarantees Gateway ‚Üî Router work as described in CP1 spec. The primary endpoint for smoke testing is `POST /api/v1/routes/decide`.

## Scope

### CP1-Smoke Requirements

**Minimal set**:
1. **[health]** `GET /_health` ‚Üí 200 JSON, conforms to `docs/OBSERVABILITY*.md`
2. **[happy-path routing]** `POST /api/v1/routes/decide`:
   - Correctly forms NATS message according to `docs/ARCHITECTURE/PROTO_NATS_MAPPING.md`
   - Router response correctly mapped to REST DTO (`docs/ARCHITECTURE/api-registry.md`)
3. **[error path]** Predictable responses for:
   - Validation error (400 Bad Request)
   - Router error (NATS unavailable / timeout) (503 Service Unavailable)
4. **[observability baseline]** JSON logs with required fields, correct status/timing for smoke scenario

## Current State Inventory

### Code

**Gateway Implementation**:
- **Location**: `apps/c-gateway/src/http_server.c`
- **Handler**: `handle_decide()` (lines 1191-1231)
- **Validation**: `validate_decide_request()` (called before processing)
- **NATS Integration**: `build_route_request_json()` ‚Üí NATS publish
- **Response Mapping**: Router response ‚Üí REST DTO mapping

**Existing Smoke Script**:
- **Location**: `scripts/smoke_c_gateway.sh`
- **Current Coverage**:
  - ‚úÖ `GET /_health` check
  - ‚úÖ `POST /api/v1/routes/decide` happy path (basic)

### Tests

**Existing Tests**:
- `scripts/gateway_router_contract_smoke.sh` - Gateway ‚Üî Router contract verification
- `scripts/smoke_c_gateway.sh` - Basic Gateway smoke test
- `tests/integration/c-gateway-routes.test.ts` - Integration tests (if available)

### Documentation

**API Contracts**:
- `docs/ARCHITECTURE/api-registry.md` - REST API DTO definitions
- `docs/API_CONTRACTS.md` - Router ‚Üî CAF contracts (includes Gateway REST API)
- `docs/archive/dev/CP1_BOUNDARIES_AND_CONTRACTS.md` - CP1 minimal contracts (lines 113-129)
- `docs/ARCHITECTURE/PROTO_NATS_MAPPING.md` - Proto ‚Üî NATS subject mapping

## CP1-Smoke Scenario Formalization

### Endpoint: `POST /api/v1/routes/decide`

**Request DTO** (from `docs/ARCHITECTURE/api-registry.md`):
```json
{
  "message": {
    "message_id": "string (UUID)",
    "tenant_id": "string (required)",
    "trace_id": "string (optional)",
    "message_type": "chat | completion | embedding",
    "payload": "string (Base64 encoded)",
    "metadata": {},
    "timestamp_ms": "number (optional)"
  },
  "policy_id": "string (optional)",
  "context": {}
}
```

**HTTP Headers**:
- `X-Tenant-ID`: required (extracted by Gateway from auth context)
- `X-Trace-ID`: optional (generated by Gateway if not provided)
- `Authorization: Bearer <api_key>`: required (if auth enabled)

**Expected NATS Subject**: `beamline.router.v1.decide`

**Expected NATS Payload** (from `docs/ARCHITECTURE/PROTO_NATS_MAPPING.md`):
```json
{
  "version": "1",
  "request_id": "uuid",
  "message": {
    "message_id": "string",
    "tenant_id": "string",
    "trace_id": "string",
    "message_type": "chat",
    "payload": "base64_encoded",
    "metadata": {}
  },
  "policy_id": "string (optional)",
  "context": {}
}
```

**Router Response** (from `docs/ARCHITECTURE/PROTO_NATS_MAPPING.md`):
```json
{
  "ok": true,
  "decision": {
    "provider_id": "string",
    "reason": "weighted | sticky | fallback | policy",
    "priority": 0,
    "expected_latency_ms": 0,
    "expected_cost": 0.0,
    "metadata": {}
  },
  "context": {
    "request_id": "string",
    "trace_id": "string"
  }
}
```

**Final REST Response** (200 OK):
```json
{
  "message_id": "string",
  "provider_id": "string",
  "reason": "weighted | sticky | fallback | policy",
  "priority": 0,
  "expected_latency_ms": 0,
  "expected_cost": 0.0,
  "currency": "USD",
  "trace_id": "string"
}
```

## Gap Analysis

### 1. REST Contracts

**How it should be**:
- Request DTO matches `docs/ARCHITECTURE/api-registry.md` (lines 48-75)
- Response DTO matches `docs/ARCHITECTURE/api-registry.md` (lines 63-75)
- Error DTO matches `docs/ARCHITECTURE/api-registry.md` (lines 77-88)

**How it is now**:
- ‚úÖ Handler exists: `handle_decide()` in `apps/c-gateway/src/http_server.c`
- ‚úÖ Validation exists: `validate_decide_request()` called before processing
- ‚ö†Ô∏è **Gap**: Need to verify DTO structure matches exactly (field names, types, optionality)

**Action Items**:
- [ ] Verify request DTO structure matches `api-registry.md`
- [ ] Verify response DTO structure matches `api-registry.md`
- [ ] Verify error DTO structure matches `api-registry.md`

### 2. NATS Routing

**How it should be**:
- Subject: `beamline.router.v1.decide` (from `PROTO_NATS_MAPPING.md`)
- Message structure: Proto fields + NATS-specific fields (`version`, `request_id`, etc.)
- Field mapping: `message`, `policy_id`, `context` from REST ‚Üí NATS

**How it is now**:
- ‚úÖ NATS client exists: `apps/c-gateway/src/nats_client_real.c`
- ‚úÖ Build function exists: `build_route_request_json()` in `http_server.c`
- ‚ö†Ô∏è **Gap**: Need to verify NATS subject and payload structure match `PROTO_NATS_MAPPING.md`

**Action Items**:
- [ ] Verify NATS subject is `beamline.router.v1.decide`
- [ ] Verify NATS payload includes all required fields (`version`, `request_id`, `message`, etc.)
- [ ] Verify field mapping (REST DTO ‚Üí NATS JSON) is correct

### 3. Error Handling

**CP1 Requirement**: Predictable set of error codes and JSON error responses

**Expected Error Scenarios**:
1. **Validation Error** (400 Bad Request):
   ```json
   {
     "error": {
       "code": "INVALID_REQUEST",
       "message": "invalid decide request DTO",
       "details": {},
       "trace_id": "string",
       "timestamp": "ISO 8601 string"
     }
   }
   ```

2. **Router Error** (503 Service Unavailable):
   ```json
   {
     "error": {
       "code": "SERVICE_UNAVAILABLE",
       "message": "Router service temporarily unavailable",
       "details": {},
       "trace_id": "string",
       "timestamp": "ISO 8601 string"
     }
   }
   ```

3. **NATS Timeout** (503 Service Unavailable):
   ```json
   {
     "error": {
       "code": "SERVICE_UNAVAILABLE",
       "message": "Request timeout",
       "details": {},
       "trace_id": "string",
       "timestamp": "ISO 8601 string"
     }
   }
   ```

**How it is now**:
- ‚úÖ Error handler exists: `send_error_response()` in `http_server.c`
- ‚ö†Ô∏è **Gap**: Need to verify error codes and JSON structure match `api-registry.md`

**Action Items**:
- [ ] Verify validation error (400) structure matches spec
- [ ] Verify Router error (503) structure matches spec
- [ ] Verify NATS timeout (503) structure matches spec
- [ ] Test all error scenarios in smoke script

### 4. Observability

**CP1 Requirement**: JSON logs with required fields, correct status/timing

**Required Log Fields** (from `docs/OBSERVABILITY.md`):
- `timestamp`: ISO 8601 format (UTC)
- `level`: ERROR, WARN, INFO, DEBUG
- `component`: "gateway"
- `message`: Human-readable message
- `context`: Additional structured context (optional)
- `trace_id`: Trace identifier (when available)
- `tenant_id`: Tenant identifier (when available)

**Health Endpoint**:
- `GET /_health` ‚Üí 200 OK with JSON:
  ```json
  {
    "status": "ok" | "degraded" | "unhealthy",
    "nats": {
      "connected": boolean
    },
    "timestamp_ms": integer
  }
  ```

**How it is now**:
- ‚úÖ Health endpoint exists: `GET /_health` in `http_server.c`
- ‚ö†Ô∏è **Gap**: Need to verify log format matches `OBSERVABILITY.md`
- ‚ö†Ô∏è **Gap**: Need to verify health endpoint JSON structure

**Action Items**:
- [ ] Verify JSON log format matches `OBSERVABILITY.md`
- [ ] Verify required log fields are present
- [ ] Verify health endpoint JSON structure
- [ ] Test logging for smoke scenario (happy path + error path)

### 5. Smoke Tooling

**CP1 Requirement**: Single command entry (`scripts/*smoke*.sh`) + clear report

**Existing Scripts**:
- ‚úÖ `scripts/smoke_c_gateway.sh` - Basic Gateway smoke test
- ‚úÖ `scripts/gateway_router_contract_smoke.sh` - Gateway ‚Üî Router contract verification

**Gap**: Need unified smoke script that:
- Starts required services (NATS, Router, Gateway)
- Runs happy path test
- Runs error path tests (validation, Router error, NATS timeout)
- Verifies logs and health endpoint
- Generates clear report

**Action Items**:
- [ ] Enhance `scripts/smoke_c_gateway.sh` or create new unified script
- [ ] Add error path tests (validation, Router error, NATS timeout)
- [ ] Add log verification
- [ ] Add health endpoint verification
- [ ] Generate clear report (pass/fail with details)

## Implementation Plan

### Phase 1: Gap Analysis (Current)

1. **Inventory current state** ‚úÖ
   - Code: Gateway handler, NATS client, validation
   - Tests: Existing smoke scripts
   - Documentation: API contracts, PROTO_NATS_MAPPING

2. **Formalize CP1-smoke scenario** ‚úÖ
   - Endpoint: `POST /api/v1/routes/decide`
   - Request/Response DTOs
   - NATS subject and payload

3. **Gap analysis** ‚úÖ (this document)
   - REST contracts
   - NATS routing
   - Error handling
   - Observability
   - Smoke tooling

### Phase 2: Implementation

1. **Verify and fix REST contracts**
   - Compare actual DTOs with `api-registry.md`
   - Fix any mismatches

2. **Verify and fix NATS routing**
   - Compare actual NATS subject/payload with `PROTO_NATS_MAPPING.md`
   - Fix any mismatches

3. **Verify and fix error handling**
   - Test all error scenarios
   - Fix error codes and JSON structure

4. **Verify and fix observability**
   - Test log format
   - Test health endpoint
   - Fix any mismatches

5. **Enhance smoke tooling**
   - Enhance `scripts/smoke_c_gateway.sh` or create unified script
   - Add error path tests
   - Add log/health verification

### Phase 3: Validation

1. **Run full smoke cycle**
   - Local scenario: `docker-compose` / `scripts/start-services.sh` + smoke scripts
   - Fix any flakiness

2. **Update documentation**
   - Update `docs/CP1_ACCEPTANCE_REPORT.md` with Gateway CP1-smoke status
   - Update `docs/API_CONTRACTS.md` if needed
   - Update `docs/ARCHITECTURE/api-registry.md` if needed

## Acceptance Criteria

### Gateway CP1-Smoke Complete

1. ‚úÖ Health endpoint (`GET /_health`) returns 200 JSON matching spec
2. ‚úÖ Happy path (`POST /api/v1/routes/decide`) works end-to-end:
   - REST request ‚Üí NATS message ‚Üí Router response ‚Üí REST response
   - All DTOs match `api-registry.md`
   - NATS subject/payload match `PROTO_NATS_MAPPING.md`
3. ‚úÖ Error paths return predictable responses:
   - Validation error (400) with correct JSON structure
   - Router error (503) with correct JSON structure
   - NATS timeout (503) with correct JSON structure
4. ‚úÖ Observability baseline:
   - JSON logs with required fields
   - Health endpoint returns correct JSON
5. ‚úÖ Smoke tooling:
   - Single command entry (`scripts/smoke_c_gateway.sh` or unified script)
   - Clear report (pass/fail with details)
   - All scenarios covered (happy path + error paths)

## Next Steps

1. **Review this plan** and confirm approach
2. **Start Phase 2**: Verify and fix REST contracts, NATS routing, error handling, observability
3. **Enhance smoke tooling**: Add error path tests, log/health verification
4. **Run full smoke cycle**: Local scenario with all services
5. **Update documentation**: CP1 acceptance report, API contracts

## References

- `docs/ARCHITECTURE/api-registry.md` - REST API DTO definitions
- `docs/API_CONTRACTS.md` - Router ‚Üî CAF contracts
- `docs/archive/dev/CP1_BOUNDARIES_AND_CONTRACTS.md` - CP1 minimal contracts
- `docs/ARCHITECTURE/PROTO_NATS_MAPPING.md` - Proto ‚Üî NATS subject mapping
- `docs/OBSERVABILITY.md` - Observability requirements
- `scripts/smoke_c_gateway.sh` - Existing Gateway smoke script
- `scripts/gateway_router_contract_smoke.sh` - Gateway ‚Üî Router contract verification
- `apps/c-gateway/src/http_server.c` - Gateway HTTP handler implementation

